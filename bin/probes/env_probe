#!/usr/bin/env bash
#./bin/env_probe
# ---- helpers ---------------------------------------------------------------
_die() { echo "env_probe: $*" >&2; exit "${2:-3}"; }

_is_bare_repo() { git rev-parse --is-bare-repository 2>/dev/null | grep -qx "true"; }

_abs() {  # portable-enough absolute path
  # linux: readlink -f; fallback: cd+pwd -P
  if command -v readlink >/dev/null 2>&1 && readlink -f / >/dev/null 2>&1; then
    readlink -f -- "${1}"
  else
    (cd "${1}" 2>/dev/null && pwd -P) || return 1
  fi
}

# ---- decision point --------------------------------------------------------
decide_root() {
  # allow explicit override from env; must be absolute and exist
  if [ -n "${ROOT:-}" ]; then
    [ -d "$ROOT" ] || _die "ROOT override is not a directory: $ROOT"
    case "$ROOT" in /*) : ;; *) _die "ROOT override must be absolute: $ROOT";; esac
    : "${ART_DIR:="$ROOT/artifacts"}"
    return 0
  fi

  # require a work tree
  git rev-parse --is-inside-work-tree >/dev/null 2>&1 \
    || _die "not inside a git work tree" 3
  _is_bare_repo && _die "bare git repository unsupported" 3

  # prefer superproject when present (submodule context)
  local super top
  super="$(git rev-parse --show-superproject-working-tree 2>/dev/null || true)"
  if [ -n "$super" ]; then
    top="$super"
  else
    top="$(git rev-parse --show-toplevel 2>/dev/null)" || _die "cannot resolve repo toplevel" 3
  fi

  # normalize and validate
  top="$(_abs "$top")" || _die "cannot resolve absolute path for: $top"
  [ -d "$top" ] || _die "resolved ROOT is not a directory: $top"

  # export decisions
  ROOT="$top"
  : "${ART_DIR:="$ROOT/artifacts"}"
  export ROOT ART_DIR
}

# ---- postconditions (call after decide_root) -------------------------------
guard_root() {
  case "$ROOT" in /*) : ;; *) _die "ROOT is not absolute after decision: $ROOT";; esac
  [ -n "$ROOT" ] && [ -d "$ROOT" ] || _die "ROOT missing or not a dir: $ROOT"
  case "$ART_DIR" in /*) : ;; *) _die "ART_DIR must be absolute: $ART_DIR";; esac
}

#VERSION="1.0.0"

#_json_escape() { sed 's/\\/\\\\/g; s/"/\\"/g' <<< "${1:-}"; }
bool() { [ "${1:-}" = "true" ] && echo true || echo false; }
_detect_git_flags() {
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    in_git=true
    git_root="$(git rev-parse --show-toplevel)"
    superproject_root="$(git rev-parse --show-superproject-working-tree 2>/dev/null || true)"
    is_submodule=false
    [ -n "$superproject_root" ] && is_submodule=true
  else
    in_git=false
    is_submodule=false
    git_root=""
    superproject_root=""
  fi
}


# ---------- detect ----------
is_codespaces=false
if [ "${CODESPACES:-}" = "true" ] || [ -n "${GITHUB_CODESPACES_PORT_FORWARDING_DOMAIN:-}" ]; then
  is_codespaces=true
fi

in_docker=false
{ [ -f /.dockerenv ] || grep -qE '/docker/|/containerd/' /proc/1/cgroup 2>/dev/null; } && in_docker=true
in_github_actions=false
[ "${GITHUB_ACTIONS:-}" = "true" ] && in_github_actions=true

print_human() {
  _detect_git_flags
  decide_root
  guard_root
  echo "environment:"
  echo "  codespaces:        $(bool "${is_codespaces:-false}")"
  echo "  docker:            $(bool "${in_docker:-false}")"
  echo "  github_actions:    $(bool "${in_github_actions:-false}")"

}


 


case "${1:-}" in
  --print-root)        decide_root; echo "$ROOT" ;;
  --print-art-dir)     decide_root; echo "${ART_DIR:-$ROOT/artifacts}" ;;
  --ensure-artifacts)  decide_root; mkdir -p "${ART_DIR:-$ROOT/artifacts}" ;;
  --print-env)         decide_root; printf 'ROOT=%s\nART_DIR=%s\n' "$ROOT" "${ART_DIR:-$ROOT/artifacts}" ;;
  --json)              decide_root; print_json_with_decisions ;;
  --is-submodule)      [ "$is_submodule" = true ] ;;
  --require-git)       [ "$in_git" = true ] || exit 4 ;;
  --help|-h)           print_help ;;
  --version)           echo "env_probe 1.0.0" ;;
  *)                   print_human  ;;
esac